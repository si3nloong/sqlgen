package codegen

import (
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"strconv"
	"text/template"

	"github.com/si3nloong/sqlgen"
	"github.com/si3nloong/sqlgen/codegen/config"
	"github.com/si3nloong/sqlgen/codegen/templates"
	"github.com/si3nloong/sqlgen/sequel"
	"github.com/si3nloong/sqlgen/sequel/strpool"
	"golang.org/x/tools/imports"
)

type Generator struct {
	config       config.Config
	dialect      sequel.Dialect
	quoteStrRune rune
	staticVar    bool
}

func (g Generator) QuoteStringBegin() string {
	return string(g.quoteStrRune)
}

func (g Generator) Quote(v string) string {
	return string(g.quoteStrRune) + v + string(g.quoteStrRune)
}

func (g Generator) QuoteStringEnd() string {
	return string(g.quoteStrRune)
}

func (g Generator) IsStaticVar() bool {
	return g.staticVar
}

func (g Generator) QuoteVar(i int) string {
	return g.dialect.QuoteVar(i)
}

func (g Generator) QuoteIdentifier(v string) string {
	if g.config.OmitQuoteIdentifier {
		return v
	}
	return g.dialect.QuoteIdentifier(v)
}

func newGenerator(cfg config.Config, dialect sequel.Dialect) *Generator {
	gen := new(Generator)
	gen.config = cfg
	switch dialect.QuoteRune() {
	case '"':
		gen.quoteStrRune = '`'
	case '`':
		gen.quoteStrRune = '"'
	default:
		gen.quoteStrRune = '"'
	}
	gen.dialect = dialect
	gen.staticVar = dialect.QuoteVar(1) == dialect.QuoteVar(0)
	return gen
}

func Init(cfg *config.Config) error {
	tmpl, err := template.ParseFS(codegenTemplates, "templates/init.yml.go.tpl")
	if err != nil {
		return err
	}

	w, err := os.OpenFile(config.DefaultConfigFile, os.O_RDWR|os.O_CREATE|os.O_TRUNC, fileMode)
	if err != nil {
		return err
	}
	defer w.Close()

	if err := tmpl.Execute(w, cfg); err != nil {
		return err
	}
	return nil
}

func renderTemplate[T templates.ModelTmplParams | struct{}](
	g *Generator,
	tmplName string,
	typeInferred bool,
	pkgPath string,
	pkgName string,
	getter string,
	dstDir string,
	dstFilename string,
	params T,
) error {
	w, blr := strpool.AcquireString(), strpool.AcquireString()
	defer func() {
		strpool.ReleaseString(w)
		strpool.ReleaseString(blr)
	}()

	impPkg := NewPackage(pkgPath, pkgName)
	tmpl, err := template.New(tmplName).Funcs(template.FuncMap{
		"quote":             g.Quote,
		"quoteVar":          g.QuoteVar,
		"quoteIdentifier":   g.QuoteIdentifier,
		"isStaticVar":       g.IsStaticVar,
		"createTable":       g.createTableStmt(),
		"alterTable":        g.alterTableStmt(),
		"insertOneStmt":     g.insertOneStmt(),
		"findByPKStmt":      g.findByPKStmt(),
		"updateByPKStmt":    g.updateByPKStmt(),
		"reserveImport":     reserveImport(impPkg),
		"castAs":            castAs(impPkg),
		"addrOf":            addrOf(impPkg),
		"typeConstraint":    g.typeConstraint(typeInferred),
		"getFieldTypeValue": getFieldTypeValue(impPkg, getter),
		"varRune":           g.varRune,
		"varStmt":           g.varStmt(),
	}).ParseFS(codegenTemplates, "templates/"+tmplName)
	if err != nil {
		return err
	}

	if err := tmpl.Execute(blr, params); err != nil {
		return err
	}

	if !g.config.SkipHeader {
		w.WriteString(fmt.Sprintf("// Code generated by sqlgen, version %s. DO NOT EDIT.\n\n", sqlgen.Version))
	}

	w.WriteString("package " + pkgName + "\n\n")

	if len(impPkg.imports) > 0 {
		w.WriteString("import (\n")
		for _, pkg := range impPkg.imports {
			if filepath.Base(pkg.Path()) == pkg.Name() {
				w.WriteString("\t" + strconv.Quote(pkg.Path()) + "\n")
			} else {
				w.WriteString("\t" + pkg.Name() + " " + strconv.Quote(pkg.Path()) + "\n")
			}
		}
		w.WriteString(")\n")
	}
	w.WriteString(blr.String())

	os.MkdirAll(dstDir, fileMode)
	fileDest := filepath.Join(dstDir, dstFilename)
	// formatted, err := format.Source([]byte(w.String()))
	// if err != nil {
	// 	return err
	// }
	formatted, err := imports.Process(fileDest, []byte(w.String()), &imports.Options{Comments: true})
	if err != nil {
		return err
	}
	blr.Reset()
	w.Reset()

	slog.Info("Creating " + fileDest)
	if err := os.WriteFile(fileDest, formatted, fileMode); err != nil {
		return err
	}
	return nil
}
