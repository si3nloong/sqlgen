package codegen

import (
	"bytes"
	"go/types"
	"log/slog"
	"os"
	"path/filepath"
	"strconv"
	"text/template"

	"github.com/si3nloong/sqlgen/sequel"
	"github.com/si3nloong/sqlgen/sequel/strpool"
	"golang.org/x/tools/imports"
)

func Init(cfg *Config) error {
	tmpl, err := template.ParseFS(codegenTemplates, "templates/init.yml.go.tpl")
	if err != nil {
		return err
	}

	f, err := os.OpenFile(DefaultConfigFile, os.O_RDWR|os.O_CREATE|os.O_TRUNC, fileMode)
	if err != nil {
		return err
	}
	defer f.Close()

	if err := tmpl.Execute(f, cfg); err != nil {
		return err
	}
	return nil
}

func renderTemplate(
	dialect sequel.Dialect,
	tmplName string,
	pkgPath string,
	pkgName string,
	dstDir string,
	dstFilename string,
) error {
	w := new(bytes.Buffer)
	blr := strpool.AcquireString()
	defer strpool.ReleaseString(blr)

	impPkg := NewPackage(pkgPath, pkgName)
	tmpl, err := template.New(tmplName).Funcs(template.FuncMap{
		"driver":   dialect.Driver,
		"quote":    dialect.QuoteIdentifier,
		"quoteVar": dialect.QuoteVar,
		// "quoteIdentifier": g.QuoteIdentifier,
		"isStaticVar": func() bool {
			return dialect.QuoteVar(1) == dialect.QuoteVar(2)
		},
		"reserveImport": reserveImport(impPkg),
		"varRune": func() string {
			return string(dialect.VarRune())
		},
	}).ParseFS(codegenTemplates, "templates/"+tmplName)
	if err != nil {
		return err
	}

	if err := tmpl.Execute(blr, struct{}{}); err != nil {
		return err
	}

	// if !g.config.SkipHeader {
	// 	w.WriteString(fmt.Sprintf("// Code generated by sqlgen, version %s; DO NOT EDIT.\n\n", sqlgen.Version))
	// }

	w.WriteString("package " + pkgName + "\n\n")

	if len(impPkg.imports) > 0 {
		w.WriteString("import (\n")
		for _, pkg := range impPkg.imports {
			if filepath.Base(pkg.Path()) == pkg.Name() {
				w.WriteString("\t" + strconv.Quote(pkg.Path()) + "\n")
			} else {
				w.WriteString("\t" + pkg.Name() + " " + strconv.Quote(pkg.Path()) + "\n")
			}
		}
		w.WriteString(")\n")
	}
	w.WriteString(blr.String())
	strpool.ReleaseString(blr)

	// log.Println(w.String())
	os.MkdirAll(dstDir, fileMode)
	fileDest := filepath.Join(dstDir, dstFilename)
	// formatted, err := format.Source([]byte(w.String()))
	// if err != nil {
	// 	return err
	// }
	formatted, err := imports.Process(fileDest, w.Bytes(), &imports.Options{Comments: true})
	if err != nil {
		return err
	}
	w.Reset()

	slog.Info("Creating " + fileDest)
	if err := os.WriteFile(fileDest, formatted, fileMode); err != nil {
		return err
	}
	return nil
}

func reserveImport(impPkgs *Package) func(pkgPath string, aliases ...string) string {
	return func(pkgPath string, aliases ...string) string {
		name := filepath.Base(pkgPath)
		if len(aliases) > 0 {
			name = aliases[0]
		}
		impPkgs.Import(types.NewPackage(pkgPath, name))
		return ""
	}
}
