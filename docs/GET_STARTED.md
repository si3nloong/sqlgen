# Getting Started

> A comprehensive guide to use sqlgen.

1.  Install `sqlgen` CLI.

    ```console
    go install github.com/si3nloong/sqlgen
    ```

2.  Define your struct.

    <h5 a><strong><code>model/user.go</code></strong></h5>

    ```go
    package model

    import "time"

    type LongText string

    type User struct {
        ID      int64 `sql:",pk,auto_increment"`
        Name    LongText
        Age     uint8
        Created time.Time
    }
    ```

3.  Generate the output files.

    ```console
    sqlgen generate ./model/user.go
    ```

4.  This will generate the output files.

    <h5 a><strong><code>model/generated.go</code></strong></h5>

    ```go
    // Code generated by sqlgen, version v1.0.0-beta. DO NOT EDIT.

    package model

    import (
        "database/sql/driver"
        "time"

        "github.com/si3nloong/sqlgen/sequel/types"
    )

    func (User) CreateTableStmt() string {
        return "CREATE TABLE IF NOT EXISTS `user` (`id` BIGINT NOT NULL AUTO_INCREMENT,`name` VARCHAR(255) NOT NULL,`age` TINYINT UNSIGNED NOT NULL,`created` DATETIME NOT NULL,PRIMARY KEY (`id`));"
    }
    func (User) AlterTableStmt() string {
        return "ALTER TABLE `user` MODIFY `id` BIGINT NOT NULL AUTO_INCREMENT,MODIFY `name` VARCHAR(255) NOT NULL AFTER `id`,MODIFY `age` TINYINT UNSIGNED NOT NULL AFTER `name`,MODIFY `created` DATETIME NOT NULL AFTER `age`;"
    }
    func (User) TableName() string {
        return "`user`"
    }
    func (User) Columns() []string {
        return []string{"`id`", "`name`", "`age`", "`created`"}
    }
    func (v User) IsAutoIncr() bool {
        return true
    }
    func (v User) PK() (columnName string, pos int, value driver.Value) {
        return "`id`", 0, int64(v.ID)
    }
    func (v User) Values() []any {
        return []any{int64(v.ID), string(v.Name), int64(v.Age), time.Time(v.Created)}
    }
    func (v *User) Addrs() []any {
        return []any{types.Integer(&v.ID), types.String(&v.Name), types.Integer(&v.Age), (*time.Time)(&v.Created)}
    }
    ```

    <h5 a><strong><code>db/db.go</code></strong></h5>

    ```go
    // Code generated by sqlgen, version v1.0.0-beta. DO NOT EDIT.

    package db

    import (
        "context"
        "database/sql"

        "github.com/si3nloong/sqlgen/sequel"
        "github.com/si3nloong/sqlgen/sequel/strpool"
    )

    func InsertOne[T sequel.KeyValuer[T], Ptr interface {
        sequel.KeyValuer[T]
        sequel.Scanner[T]
    }](ctx context.Context, db sequel.DB, v Ptr) (sql.Result, error) {
        columns, args := v.Columns(), v.Values()
        switch vi := any(v).(type) {
        case sequel.Keyer:
            if vi.IsAutoIncr() {
                // If it's a auto increment primary key
                // We don't need to pass the value
                _, idx, _ := vi.PK()
                columns = append(columns[:idx], columns[idx+1:]...)
                args = append(args[:idx], args[idx+1:]...)
            }
        }
        var (
            noOfCols = len(columns)
            stmt     = strpool.AcquireString()
        )
        defer strpool.ReleaseString(stmt)
        stmt.WriteString("INSERT INTO " + v.TableName() + " (")
        for i := 0; i < noOfCols; i++ {
            if i > 0 {
                stmt.WriteString("," + columns[i])
            } else {
                stmt.WriteString(columns[i])
            }
        }
        stmt.WriteString(") VALUES (")
        for i := range args {
            if i > 0 {
                stmt.WriteByte(',')
            }
            stmt.WriteByte('?')
        }
        stmt.WriteString(");")
        return db.ExecContext(ctx, stmt.String(), args...)
    }

    // FindByID is to find single record using primary key.
    func FindByID[T sequel.KeyValuer[T], Ptr sequel.KeyValueScanner[T]](ctx context.Context, db sequel.DB, v Ptr) error {
        var (
            pkName, _, pk = v.PK()
            columns       = v.Columns()
            stmt          = strpool.AcquireString()
        )
        defer strpool.ReleaseString(stmt)
        stmt.WriteString("SELECT ")
        for i := range columns {
            if i > 0 {
                stmt.WriteByte(',')
            }
            stmt.WriteString(columns[i])
        }
        stmt.WriteString(" FROM " + v.TableName() + " WHERE " + pkName + " = ? LIMIT 1;")
        return db.QueryRowContext(ctx, stmt.String(), pk).Scan(v.Addrs()...)
    }

    // UpdateByID is to update single record using primary key.
    func UpdateByID[T sequel.KeyValuer[T]](ctx context.Context, db sequel.DB, v T) (sql.Result, error) {
        var (
            pkName, idx, pk = v.PK()
            columns, values = v.Columns(), v.Values()
            stmt            = strpool.AcquireString()
        )
        columns = append(columns[:idx], columns[idx+1:]...)
        values = append(values[:idx], values[idx+1:]...)
        var noOfCols = len(columns)
        defer strpool.ReleaseString(stmt)
        stmt.WriteString("UPDATE " + v.TableName() + " SET ")
        for i := 0; i < noOfCols; i++ {
            if i > 0 {
                stmt.WriteByte(',')
            }
            stmt.WriteString(columns[i] + " = ?")
        }
        stmt.WriteString(" WHERE " + pkName + " = ?;")
        return db.ExecContext(ctx, stmt.String(), append(values, pk)...)
    }

    // DeleteByID is to update single record using primary key.
    func DeleteByID[T sequel.KeyValuer[T]](ctx context.Context, db sequel.DB, v T) (sql.Result, error) {
        var (
            pkName, _, pk = v.PK()
            stmt          = strpool.AcquireString()
        )
        defer strpool.ReleaseString(stmt)
        stmt.WriteString("DELETE FROM " + v.TableName() + " WHERE " + pkName + " = ?;")

        return db.ExecContext(ctx, stmt.String(), pk)
    }
    ```

5.  We can now utilise the generated codes.

    <h5 a><strong><code>main.go</code></strong></h5>

    ```go
    package main

    import (
        "context"
        "database/sql"
        "log"
        "time"

        "db"
        "model"

        _ "github.com/go-sql-driver/mysql"
    )

    func main() {
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()
        dbConn, err := sql.Open("mysql", "root:abcd1234@/sqlbench?parseTime=true")
        if err != nil {
            panic(err)
        }
        defer dbConn.Close()

        // table migration
        if err := db.Migrate[model.User](ctx, dbConn); err != nil {
            panic(err)
        }

        user := model.User{}
        user.Name = "Micheal"
        user.Age = 18
        user.Created = time.Now()
        // insert single record
        result, err := db.InsertOne(ctx, dbConn, &user)
        if err != nil {
            panic(err)
        }

        newUser := model.User{}
        newUser.ID, _ = result.LastInsertId()
        // find record by id
        if err := db.FindByID(ctx, dbConn, &newUser); err != nil {
            panic(err)
        }
        log.Println(newUser)

        newUser.Age = 27
        // update record by id
        if _, err := db.UpdateByID(ctx, dbConn, newUser); err != nil {
            panic(err)
        }
        log.Println(newUser)

        // remove record by id
        if _, err := db.DeleteByID(ctx, dbConn, newUser); err != nil {
            panic(err)
        }
    }

    ```
