# Getting Started

> A comprehensive guide to use sqlgen.

1.  Install `sqlgen` CLI.

    ```console
    go install github.com/si3nloong/sqlgen
    ```

2.  Define your [model](./MODELS.md) struct.

    <h5 a><strong><code>model/user.go</code></strong></h5>

    ```go
    package model

    import (
        "time"

        "cloud.google.com/go/civil"
    )

    type Gender int

    const (
        Female Gender = iota
        Male
    )

    type User struct {
        ID        int64 `sql:",auto_increment"`
        Name      string
        BirthDate civil.Date
        Gender    Gender
        Address   string
        Created   time.Time
    }
    ```

    But I prefer `UUID` primary key, how can I do that? To do that, you may refer to [here](./UUID.md).

3.  Generate the output files.

    ```console
    sqlgen generate ./model/user.go
    ```

4.  This will generate the output files.

    <h5 a><strong><code>model/generated.go</code></strong></h5>

    ```go
    // Code generated by sqlgen, version v1.0.0-alpha.1. DO NOT EDIT.

    package model

    import (
        "database/sql/driver"
        "time"

        "cloud.google.com/go/civil"
        "github.com/si3nloong/sqlgen/sequel"
        "github.com/si3nloong/sqlgen/sequel/types"
    )

    func (v User) CreateTableStmt() string {
        return "CREATE TABLE IF NOT EXISTS " + v.TableName() + " (`id` BIGINT NOT NULL AUTO_INCREMENT,`name` VARCHAR(255) NOT NULL,`birth_date` DATE NOT NULL,`gender` INTEGER NOT NULL,`address` VARCHAR(255) NOT NULL,`created` DATETIME NOT NULL,PRIMARY KEY (`id`));"
    }
    func (User) AlterTableStmt() string {
        return "ALTER TABLE `user` MODIFY `id` BIGINT NOT NULL AUTO_INCREMENT,MODIFY `name` VARCHAR(255) NOT NULL AFTER `id`,MODIFY `birth_date` DATE NOT NULL AFTER `name`,MODIFY `gender` INTEGER NOT NULL AFTER `birth_date`,MODIFY `address` VARCHAR(255) NOT NULL AFTER `gender`,MODIFY `created` DATETIME NOT NULL AFTER `address`;"
    }
    func (User) TableName() string {
        return "`user`"
    }
    func (User) InsertVarQuery() string {
        return "(?,?,?,?,?,?)"
    }
    func (User) Columns() []string {
        return []string{"`id`", "`name`", "`birth_date`", "`gender`", "`address`", "`created`"}
    }
    func (v User) IsAutoIncr() bool {
        return true
    }
    func (v User) PK() (columnName string, pos int, value driver.Value) {
        return "`id`", 0, int64(v.ID)
    }
    func (v User) Values() []any {
        return []any{int64(v.ID), string(v.Name), types.TextMarshaler(v.BirthDate), int64(v.Gender), string(v.Address), time.Time(v.Created)}
    }
    func (v *User) Addrs() []any {
        return []any{types.Integer(&v.ID), types.String(&v.Name), types.Date(&v.BirthDate), types.Integer(&v.Gender), types.String(&v.Address), (*time.Time)(&v.Created)}
    }
    func (v User) GetID() sequel.ColumnValuer[int64] {
        return sequel.Column[int64]("`id`", v.ID, func(vi int64) driver.Value { return int64(vi) })
    }
    func (v User) GetName() sequel.ColumnValuer[string] {
        return sequel.Column[string]("`name`", v.Name, func(vi string) driver.Value { return string(vi) })
    }
    func (v User) GetBirthDate() sequel.ColumnValuer[civil.Date] {
        return sequel.Column[civil.Date]("`birth_date`", v.BirthDate, func(vi civil.Date) driver.Value { return types.TextMarshaler(vi) })
    }
    func (v User) GetGender() sequel.ColumnValuer[Gender] {
        return sequel.Column[Gender]("`gender`", v.Gender, func(vi Gender) driver.Value { return int64(vi) })
    }
    func (v User) GetAddress() sequel.ColumnValuer[string] {
        return sequel.Column[string]("`address`", v.Address, func(vi string) driver.Value { return string(vi) })
    }
    func (v User) GetCreated() sequel.ColumnValuer[time.Time] {
        return sequel.Column[time.Time]("`created`", v.Created, func(vi time.Time) driver.Value { return time.Time(vi) })
    }
    ```

    <h5 a><strong><code>db/db.go</code></strong></h5>

    ```go
    // Code generated by sqlgen, version v1.0.0-alpha.1. DO NOT EDIT.

    package db

    import (
        "context"
        "database/sql"

        "github.com/si3nloong/sqlgen/sequel"
        "github.com/si3nloong/sqlgen/sequel/strpool"
    )

    func InsertOne[T sequel.KeyValuer[T], Ptr interface {
        sequel.KeyValuer[T]
        sequel.Scanner[T]
    }](ctx context.Context, db sequel.DB, v Ptr) (sql.Result, error) {
        columns, args := v.Columns(), v.Values()
        switch vi := any(v).(type) {
        case sequel.Keyer:
            if vi.IsAutoIncr() {
                // If it's a auto increment primary key
                // We don't need to pass the value
                _, idx, _ := vi.PK()
                columns = append(columns[:idx], columns[idx+1:]...)
                args = append(args[:idx], args[idx+1:]...)
            }
        }
        var (
            noOfCols = len(columns)
            stmt     = strpool.AcquireString()
        )
        defer strpool.ReleaseString(stmt)
        stmt.WriteString("INSERT INTO " + v.TableName() + " (")
        for i := 0; i < noOfCols; i++ {
            if i > 0 {
                stmt.WriteString("," + columns[i])
            } else {
                stmt.WriteString(columns[i])
            }
        }
        stmt.WriteString(") VALUES (")
        for i := range args {
            if i > 0 {
                stmt.WriteByte(',')
            }
            stmt.WriteByte('?')
        }
        stmt.WriteString(");")
        return db.ExecContext(ctx, stmt.String(), args...)
    }

    // FindByID is to find single record using primary key.
    func FindByID[T sequel.KeyValuer[T], Ptr sequel.KeyValueScanner[T]](ctx context.Context, db sequel.DB, v Ptr) error {
        var (
            pkName, _, pk = v.PK()
            columns       = v.Columns()
            stmt          = strpool.AcquireString()
        )
        defer strpool.ReleaseString(stmt)
        stmt.WriteString("SELECT ")
        for i := range columns {
            if i > 0 {
                stmt.WriteByte(',')
            }
            stmt.WriteString(columns[i])
        }
        stmt.WriteString(" FROM " + v.TableName() + " WHERE " + pkName + " = ? LIMIT 1;")
        return db.QueryRowContext(ctx, stmt.String(), pk).Scan(v.Addrs()...)
    }

    // UpdateByID is to update single record using primary key.
    func UpdateByID[T sequel.KeyValuer[T]](ctx context.Context, db sequel.DB, v T) (sql.Result, error) {
        var (
            pkName, idx, pk = v.PK()
            columns, values = v.Columns(), v.Values()
            stmt            = strpool.AcquireString()
        )
        columns = append(columns[:idx], columns[idx+1:]...)
        values = append(values[:idx], values[idx+1:]...)
        var noOfCols = len(columns)
        defer strpool.ReleaseString(stmt)
        stmt.WriteString("UPDATE " + v.TableName() + " SET ")
        for i := 0; i < noOfCols; i++ {
            if i > 0 {
                stmt.WriteByte(',')
            }
            stmt.WriteString(columns[i] + " = ?")
        }
        stmt.WriteString(" WHERE " + pkName + " = ?;")
        return db.ExecContext(ctx, stmt.String(), append(values, pk)...)
    }

    // DeleteByID is to update single record using primary key.
    func DeleteByID[T sequel.KeyValuer[T]](ctx context.Context, db sequel.DB, v T) (sql.Result, error) {
        var (
            pkName, _, pk = v.PK()
            stmt          = strpool.AcquireString()
        )
        defer strpool.ReleaseString(stmt)
        stmt.WriteString("DELETE FROM " + v.TableName() + " WHERE " + pkName + " = ?;")

        return db.ExecContext(ctx, stmt.String(), pk)
    }
    ```

    <h5 a><strong><code>db/operator.go</code></strong></h5>

    ```go
    // Code generated by sqlgen, version v1.0.0-alpha.1. DO NOT EDIT.

    package db

    import (
        "github.com/si3nloong/sqlgen/sequel"
    )

    func And(stmts ...sequel.WhereClause) sequel.WhereClause {
        return func(stmt sequel.StmtBuilder) {
            stmt.WriteByte('(')
            for i := range stmts {
                if i > 0 {
                    stmt.WriteString(" AND ")
                }
                stmts[i](stmt)
            }
            stmt.WriteByte(')')
        }
    }

    func Or(stmts ...sequel.WhereClause) sequel.WhereClause {
        return func(stmt sequel.StmtBuilder) {
            stmt.WriteByte('(')
            for i := range stmts {
                if i > 0 {
                    stmt.WriteString(" OR ")
                }
                stmts[i](stmt)
            }
            stmt.WriteByte(')')
        }
    }

    func Equal[T comparable](f sequel.ColumnValuer[T], value T) sequel.WhereClause {
        return func(stmt sequel.StmtBuilder) {
            stmt.Var(f.ColumnName()+" = ", f.Convert(value))
        }
    }

    func NotEqual[T comparable](f sequel.ColumnValuer[T], value T) sequel.WhereClause {
        return func(stmt sequel.StmtBuilder) {
            stmt.Var(f.ColumnName()+" <> ", f.Convert(value))
        }
    }

    func In[T any](f sequel.ColumnValuer[T], values ...T) sequel.WhereClause {
        return func(stmt sequel.StmtBuilder) {
            args := make([]any, len(values))
            for idx := range values {
                args[idx] = f.Convert(values[idx])
            }
            stmt.Var(f.ColumnName()+" IN ", args...)
        }
    }

    func NotIn[T any](f sequel.ColumnValuer[T], values ...T) sequel.WhereClause {
        return func(stmt sequel.StmtBuilder) {
            args := make([]any, len(values))
            for idx := range values {
                args[idx] = f.Convert(values[idx])
            }
            stmt.Var(f.ColumnName()+" NOT IN ", args...)
        }
    }

    func GreaterThan[T comparable](f sequel.ColumnValuer[T], value T) sequel.WhereClause {
        return func(stmt sequel.StmtBuilder) {
            stmt.Var(f.ColumnName()+" > ", f.Convert(value))
        }
    }

    func GreaterThanOrEqual[T comparable](f sequel.ColumnValuer[T], value T) sequel.WhereClause {
        return func(stmt sequel.StmtBuilder) {
            stmt.Var(f.ColumnName()+" >= ", f.Convert(value))
        }
    }

    func LessThan[T comparable](f sequel.ColumnValuer[T], value T) sequel.WhereClause {
        return func(stmt sequel.StmtBuilder) {
            stmt.Var(f.ColumnName()+" < ", f.Convert(value))
        }
    }

    func LessThanOrEqual[T comparable](f sequel.ColumnValuer[T], value T) sequel.WhereClause {
        return func(stmt sequel.StmtBuilder) {
            stmt.Var(f.ColumnName()+" >= ", f.Convert(value))
        }
    }

    func Like[T comparable](f sequel.ColumnValuer[T], value T) sequel.WhereClause {
        return func(stmt sequel.StmtBuilder) {
            stmt.Var(f.ColumnName()+" LIKE ", f.Convert(value))
        }
    }

    func NotLike[T comparable](f sequel.ColumnValuer[T], value T) sequel.WhereClause {
        return func(stmt sequel.StmtBuilder) {
            stmt.Var(f.ColumnName()+" NOT LIKE ", f.Convert(value))
        }
    }

    func IsNull[T any](f sequel.ColumnValuer[T]) sequel.WhereClause {
        return func(stmt sequel.StmtBuilder) {
            stmt.WriteString(f.ColumnName() + " IS NULL")
        }
    }

    func IsNotNull[T any](f sequel.ColumnValuer[T]) sequel.WhereClause {
        return func(stmt sequel.StmtBuilder) {
            stmt.WriteString(f.ColumnName() + " IS NOT NULL")
        }
    }

    func Asc[T any](f sequel.ColumnValuer[T]) sequel.OrderByClause {
        return func(sw sequel.StmtWriter) {
            sw.WriteString(f.ColumnName() + " ASC")
        }
    }

    func Desc[T any](f sequel.ColumnValuer[T]) sequel.OrderByClause {
        return func(sw sequel.StmtWriter) {
            sw.WriteString(f.ColumnName() + " DESC")
        }
    }
    ```

5.  We can now utilise the generated codes.

    <h5 a><strong><code>main.go</code></strong></h5>

    ```go
    package main

    import (
        "context"
        "database/sql"
        "log"
        "time"

        "db"
        "model"

        _ "github.com/go-sql-driver/mysql"
    )

    func main() {
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()
        dbConn, err := sql.Open("mysql", "root:abcd1234@/sqlbench?parseTime=true")
        if err != nil {
            panic(err)
        }
        defer dbConn.Close()

        // table migration
        if err := db.Migrate[model.User](ctx, dbConn); err != nil {
            panic(err)
        }

        user := model.User{}
        user.Name = "Micheal"
        user.Age = 18
        user.Created = time.Now()
        // insert single record
        result, err := db.InsertOne(ctx, dbConn, &user)
        if err != nil {
            panic(err)
        }

        inputs := []model.User{
            {Name: "John", Created: time.Now()},
            {Name: "Michael", Created: time.Now()},
            {Name: "Jerry", Created: time.Now()},
        }
        // insert multiple record
        if _, err := db.InsertInto(ctx, dbConn, inputs); err != nil {
            panic(err)
        }

        newUser := model.User{}
        newUser.ID, _ = result.LastInsertId()
        // find record by id
        if err := db.FindByID(ctx, dbConn, &newUser); err != nil {
            panic(err)
        }
        log.Println(newUser)

        newUser.Age = 27
        // update record by id
        if _, err := db.UpdateByID(ctx, dbConn, newUser); err != nil {
            panic(err)
        }
        log.Println(newUser)

        // remove record by id
        if _, err := db.DeleteByID(ctx, dbConn, newUser); err != nil {
            panic(err)
        }
    }
    ```

    But these seem too easy to handle my use case, I need to handle more complex statements. Don't worry, we do provide `QueryStmt` to support more complex statements such as dynamic SQL statement.

    For example :

    <h5 a><strong><code>main.go</code></strong></h5>

    ```go
    package main

    import (
        "context"
        "database/sql"
        "log"
        "time"

        "cloud.google.com/go/civil"
        _ "github.com/go-sql-driver/mysql"
        "db"
        "model"
    )

    func main() {
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()
        dbConn, err := sql.Open("mysql", "root:abcd1234@/sqlbench?parseTime=true")
        if err != nil {
            panic(err)
        }
        defer dbConn.Close()

        if err := db.Migrate[model.User](ctx, dbConn); err != nil {
            panic(err)
        }

        birthDate, _ := civil.ParseDate("1995-01-28")

        if _, err := db.InsertInto(ctx, dbConn, []model.User{
            {Name: "John Doe", Gender: model.Male, BirthDate: birthDate, Created: time.Now()},
            {Name: "YY", Gender: model.Female, BirthDate: birthDate, Created: time.Now()},
            {Name: "Yoman", Gender: model.Male, BirthDate: birthDate, Created: time.Now()},
        }); err != nil {
            panic(err)
        }

        users, err := db.QueryStmt[model.User](ctx, dbConn, db.SelectStmt{
            Select:    user.Columns(),
            FromTable: user.TableName(),
            Where: db.And(
                db.Equal(user.GetGender(), model.Female),
                db.GreaterThanOrEqual(user.GetBirthDate(), birthDate),
            ),
            OrderBy: []sequel.OrderByClause{
                db.Desc(user.GetCreated()),
            },
            Limit: 50,
        })
        if err != nil {
            panic(err)
        }
        log.Println("Users ->", users)
    }
    ```
