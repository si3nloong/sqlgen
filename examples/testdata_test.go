package examples_test

import (
	"bufio"
	"bytes"
	"fmt"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"testing"

	"github.com/si3nloong/sqlgen"
	"github.com/si3nloong/sqlgen/codegen/config"
	_ "github.com/si3nloong/sqlgen/sequel/dialect/mysql"
	_ "github.com/si3nloong/sqlgen/sequel/dialect/postgres"
	_ "github.com/si3nloong/sqlgen/sequel/dialect/sqlite"

	"github.com/si3nloong/sqlgen/codegen"
	"github.com/si3nloong/sqlgen/internal/fileutil"
	"github.com/stretchr/testify/require"
)

func TestAll(t *testing.T) {
	const rootDir = "./testcase"

	if err := codegen.Generate(&config.Config{
		Source: []string{rootDir + "/**/*.go"},
	}); err != nil {
		t.Fatal(err)
	}

	if err := patchVersionInFiles(t, rootDir); err != nil {
		t.Fatal(err)
	}
	panic("")
	// Re-generate all files
	if err := generateModel(t, rootDir); err != nil {
		t.Fatal(err)
	}
}

func patchVersionInFiles(t *testing.T, rootDir string) error {
	headerRegex := regexp.MustCompile(`\/\/ Code generated by sqlgen, version (.*)\. DO NOT EDIT\.`)
	return filepath.WalkDir(rootDir, func(path string, d fs.DirEntry, err error) error {
		if !d.IsDir() {
			return nil
		}
		log.Println("Path ->", path)

		// if fileutil.IsDirEmptyFiles(path) {
		// 	return nil
		// }

		// Read result file
		filename := filepath.Join(path, config.DefaultGeneratedFile+".tpl")
		f, err := os.OpenFile(filename, os.O_RDWR, 0o755)
		if err != nil {
			if os.IsNotExist(err) {
				return nil
			}
			return fmt.Errorf("%w, happened in directory %q", err, path)
		}
		defer f.Close()

		r := bufio.NewReader(f)
		line, _, err := r.ReadLine()
		if err != nil {
			return err
		}

		matches := headerRegex.FindSubmatch(line)
		if len(matches) > 1 {
			newVersion := []byte(sqlgen.Version)
			if bytes.Equal(matches[1], newVersion) {
				return nil
			}

			f.Seek(int64(len(line)), 0)

			log.Println("Patching " + filename)
			log.Println(string(bytes.ReplaceAll(line, matches[1], newVersion)))
			// log.Println(f.Seek(0, 0))
			// f.WriteAt(append(bytes.ReplaceAll(line, matches[1], newVersion), '\n', '\n'), 0)
		}

		return nil
	})
}

func generateModel(t *testing.T, rootDir string) error {
	return filepath.Walk(rootDir, func(path string, info fs.FileInfo, e error) error {
		if e != nil {
			return e
		}
		if !info.IsDir() {
			return nil
		}

		if fileutil.IsDirEmptyFiles(path) {
			return nil
		}

		actual, err := os.ReadFile(filepath.Join(path, config.DefaultGeneratedFile))
		if err != nil {
			return err
		}

		// Read result file
		expected, err := os.ReadFile(filepath.Join(path, config.DefaultGeneratedFile+".tpl"))
		if err != nil {
			return fmt.Errorf("%w, happened in directory %q", err, path)
		}

		t.Run("Compare the []byte in directory "+path, func(t *testing.T) {
			require.Equal(t, expected, actual)
		})

		return nil
	})
}
